<!-- Markov Chain Section -->
<div class="card mb-4">
    <div class="card-header">
        <h2>Category Transitions (Markov Chain)</h2>
    </div>
    <div class="card-body">
        <div id="markov-graph-container"
            style="width: 100%; height: 600px; border: 1px solid #ddd; border-radius: 5px; position: relative; overflow: hidden; background: #f8f9fa;">
            <svg id="markov-graph-svg" width="100%" height="100%"></svg>
        </div>
        <div id="markov-stats" class="mt-2">
            <p class="text-muted small">Waiting for Markov chain data...</p>
        </div>
    </div>
</div>

<script>
    // Function to render Markov chain graph
    function renderMarkovGraph(markovGraph) {
        const svg = document.getElementById('markov-graph-svg');
        const container = document.getElementById('markov-graph-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        // Clear previous content
        svg.innerHTML = '';

        const nodes = markovGraph.nodes;
        const edges = markovGraph.edges;

        if (nodes.length === 0) {
            return;
        }

        // Define arrowhead marker FIRST (before drawing edges that reference it)
        // Using default markerUnits (userSpaceOnUse) so arrowheads stay same size regardless of stroke width
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', 'arrowhead');
        marker.setAttribute('markerWidth', '10');
        marker.setAttribute('markerHeight', '10');
        marker.setAttribute('refX', '9');
        marker.setAttribute('refY', '5');
        marker.setAttribute('orient', 'auto');
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('points', '0 0, 10 5, 0 10');
        polygon.setAttribute('fill', '#666');
        marker.appendChild(polygon);
        defs.appendChild(marker);
        svg.appendChild(defs);

        // Position nodes in a circle
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 3;

        const nodePositions = {};
        const colors = {
            'technology': '#36A2EB',
            'sports': '#FF6384',
            'world': '#4BC0C0',
            'entertainment': '#FFCE56',
            'health': '#4CAF50',
            'business': '#9966FF',
            'politics': '#FF9900'
        };

        nodes.forEach((node, i) => {
            const angle = (i / nodes.length) * 2 * Math.PI - Math.PI / 2;
            nodePositions[node.id] = {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle),
                label: node.label,
                count: node.count
            };
        });

        // Draw edges (arrows)
        edges.forEach(edge => {
            const from = nodePositions[edge.from];
            const to = nodePositions[edge.to];

            if (!from || !to) return;

            let pathD;
            let cx, cy;

            if (edge.from === edge.to) {
                // Self-loop
                // Calculate direction from center to node to orient the loop outwards
                const dx = from.x - centerX;
                const dy = from.y - centerY;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / len; // Normalized vector
                const ny = dy / len;

                // Loop control points
                // We want the loop to stick out by 'loopSize'
                const loopSize = 50;
                const loopWidth = 30;

                // Perpendicular vector
                const px = -ny;
                const py = nx;

                // Control point 1
                const cp1x = from.x + nx * loopSize + px * loopWidth;
                const cp1y = from.y + ny * loopSize + py * loopWidth;

                // Control point 2
                const cp2x = from.x + nx * loopSize - px * loopWidth;
                const cp2y = from.y + ny * loopSize - py * loopWidth;

                pathD = `M${from.x},${from.y} C${cp1x},${cp1y} ${cp2x},${cp2y} ${from.x},${from.y}`;

                // Label position (approximate tip of the loop)
                cx = from.x + nx * (loopSize + 10);
                cy = from.y + ny * (loopSize + 10);

            } else {
                // Normal edge
                const dx = to.x - from.x;
                const dy = to.y - from.y;

                // Midpoint
                const mx = (from.x + to.x) / 2;
                const my = (from.y + to.y) / 2;

                // Perpendicular vector for control point
                const dist = Math.sqrt(dx * dx + dy * dy);
                const offset = 40; // Curve amount

                if (dist === 0) return; // Should be handled by self-loop check, but safety first

                // Control point
                cx = mx - (dy / dist) * offset;
                cy = my + (dx / dist) * offset;

                pathD = `M${from.x},${from.y} Q${cx},${cy} ${to.x},${to.y}`;
            }

            // Create curved path
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathD);
            path.setAttribute('stroke', '#666');
            path.setAttribute('stroke-width', Math.max(1.5, edge.probability * 4));
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.7');
            path.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(path);

            // Add probability label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', cx);
            text.setAttribute('y', cy);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '10');
            text.setAttribute('fill', '#666');
            text.textContent = (edge.probability * 100).toFixed(0) + '%';
            svg.appendChild(text);
        });

        // Draw nodes
        Object.keys(nodePositions).forEach(nodeId => {
            const pos = nodePositions[nodeId];

            // Node circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', pos.x);
            circle.setAttribute('cy', pos.y);
            circle.setAttribute('r', Math.min(30, 15 + Math.sqrt(pos.count) * 2));
            circle.setAttribute('fill', colors[nodeId] || '#999');
            circle.setAttribute('stroke', '#fff');
            circle.setAttribute('stroke-width', '2');
            svg.appendChild(circle);

            // Node label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '11');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', '#fff');
            text.textContent = pos.label;
            svg.appendChild(text);
        });

        // Update stats
        const statsDiv = document.getElementById('markov-stats');
        const totalTransitions = edges.length;
        statsDiv.innerHTML = `
        <p class="small mb-0"><strong>Nodes:</strong> ${nodes.length} categories</p>
        <p class="small mb-0"><strong>Transitions:</strong> ${totalTransitions} paths</p>
        <p class="small text-muted mb-0">Arrow thickness = transition probability</p>
    `;
    }
</script>